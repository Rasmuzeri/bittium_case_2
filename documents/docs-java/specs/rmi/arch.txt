Java Remote Method Invocation: 3 - RMI System Overview
3 RMI System Overview
Stubs and Skeletons
Thread Usage in
Remote Method Invocations
Garbage Collection
of Remote Objects
Dynamic Class Loading
RMI Through Firewalls
Via Proxies
3.1 Stubs and Skeletons
RMI uses a standard mechanism (employed in RPC systems) for
communicating with remote objects:
stubs
and
skeletons
. A stub for a remote object acts as a client's local
representative or proxy for the remote object. The caller invokes a
method on the local stub which is responsible for carrying out the
method call on the remote object. In RMI, a stub for a remote object
implements the same set of remote interfaces that a remote object
implements.
When a stub's method is invoked, it does the following:
initiates a connection with the remote JVM containing the remote
object,
marshals (writes and transmits) the parameters to the remote
JVM,
waits for the result of the method invocation,
unmarshals (reads) the return value or exception returned, and
returns the value to the caller.
The stub hides the serialization of parameters and the network-level
communication in order to present a simple invocation mechanism to the
caller.
In the remote JVM, each remote object may have a corresponding
skeleton (in Java 2 platform-only environments, skeletons are not
required). The skeleton is responsible for dispatching the call to the
actual remote object implementation. When a skeleton receives an
incoming method invocation it does the following:
unmarshals (reads) the parameters for the remote method,
invokes the method on the actual remote object implementation,
and
marshals (writes and transmits) the result (return value or
exception) to the caller.
In the Java 2 SDK, Standard Edition, v1.2 an additional stub protocol
was introduced that eliminates the need for skeletons in Java 2
platform-only environments. Instead, generic code is used to carry out
the duties performed by skeletons in JDK1.1. Stubs and skeletons are
generated by the
rmic
compiler.
3.2 Thread Usage in
Remote Method Invocations
A method dispatched by the RMI runtime to a remote object
implementation may or may not execute in a separate thread. The RMI
runtime makes no guarantees with respect to mapping remote object
invocations to threads. Since remote method invocation on the same
remote object may execute concurrently, a remote object implementation
needs to make sure its implementation is thread-safe.
3.3 Garbage Collection of
Remote Objects
In a distributed system, just as in the local system, it is desirable
to automatically delete those remote objects that are no longer
referenced by any client. This frees the programmer from needing to keep
track of the remote objects' clients so that it can terminate
appropriately. RMI uses a reference-counting garbage collection
algorithm similar to Modula-3's Network Objects. (See "Network Objects"
by Birrell, Nelson, and Owicki,
Digital Equipment Corporation
Systems Research Center Technical Report 115
, 1994.)
To accomplish reference-counting garbage collection, the RMI runtime
keeps track of all live references within each Java virtual machine.
When a live reference enters a Java virtual machine, its reference count
is incremented. The first reference to an object sends a "referenced"
message to the server for the object. As live references are found to be
unreferenced in the local virtual machine, the count is decremented.
When the last reference has been discarded, an unreferenced message is
sent to the server. Many subtleties exist in the protocol; most of these
are related to maintaining the ordering of referenced and unreferenced
messages in order to ensure that the object is not prematurely
collected.
When a remote object is not referenced by any client, the RMI runtime
refers to it using a weak reference. The weak reference allows the Java
virtual machine's garbage collector to discard the object if no other
local references to the object exist. The distributed garbage collection
algorithm interacts with the local Java virtual machine's garbage
collector in the usual ways by holding normal or weak references to
objects.
As long as a local reference to a remote object exists, it cannot be
garbage-collected and it can be passed in remote calls or returned to
clients. Passing a remote object adds the identifier for the virtual
machine to which it was passed to the referenced set. A remote object
needing unreferenced notification must implement the
java.rmi.server.Unreferenced
interface. When those
references no longer exist, the
unreferenced
method will be
invoked.
unreferenced
is called when the set of references
is found to be empty so it might be called more than once. Remote
objects are only collected when no more references, either local or
remote, still exist.
Note that if a network partition exists between a client and a remote
server object, it is possible that premature collection of the remote
object will occur (since the transport might believe that the client
crashed). Because of the possibility of premature collection, remote
references cannot guarantee referential integrity; in other words, it is
always possible that a remote reference may in fact not refer to an
existing object. An attempt to use such a reference will generate a
RemoteException
which must be handled by the
application.
3.4 Dynamic Class Loading
RMI allows parameters, return values and exceptions passed in RMI
calls to be any object that is serializable. RMI uses the object
serialization mechanism to transmit data from one virtual machine to
another and also annotates the call stream with the appropriate location
information so that the class definition files can be loaded at the
receiver.
When parameters and return values for a remote method invocation are
unmarshalled to become live objects in the receiving JVM, class
definitions are required for all of the types of objects in the stream.
The unmarshalling process first attempts to resolve classes by name in
its local class loading context (the context class loader of the current
thread). RMI also provides a facility for dynamically loading the class
definitions for the actual types of objects passed as parameters and
return values for remote method invocations from network locations
specified by the transmitting endpoint. This includes the dynamic
downloading of remote stub classes corresponding to particular remote
object implementation classes (and used to contain remote references) as
well as any other type that is passed by value in RMI calls, such as the
subclass of a declared parameter type, that is not already available in
the class loading context of the unmarshalling side.
To support dynamic class loading, the RMI runtime uses special
subclasses of
java.io.ObjectOutputStream
and
java.io.ObjectInputStream
for the marshal streams that it
uses for marshalling and unmarshalling RMI parameters and return values.
These subclasses respectively override the
annotateClass
method of
ObjectOutputStream
and the
resolveClass
method of
ObjectInputStream
to
communicate information about where to locate class files containing the
definitions for classes corresponding to the class descriptors in the
stream.
For every class descriptor written to an RMI marshal stream, the
annotateClass
method adds to the stream the result of
calling
java.rmi.server.RMIClassLoader.getClassAnnotation
for the class object, which may be
null
or may be a
String
object representing the codebase URL path (a
space-separated list of URLs) from which the remote endpoint should
download the class definition file for the given class.
For every class descriptor read from an RMI marshal stream, the
resolveClass
method reads a single object from the stream.
If the object is a String (and the value of the
java.rmi.server.useCodebaseOnly
property is not
true
), then
resolveClass
returns the result of
calling
RMIClassLoader.loadClass
with the annotated
String
object as the first parameter and the name of the
desired class in the class descriptor as the second parameter.
Otherwise,
resolveClass
returns the result of calling
RMIClassLoader.loadClass
with the name of the desired class
as the only parameter.
See the section
"The
RMIClassLoader Class"
for more details about class loading in
RMI.
3.5 RMI Through Firewalls Via
Proxies
The implementation of RMI calls through firewalls via proxies has
been removed as of JDK 9.
Copyright
Â© 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.
All rights reserved. Use is subject to
license terms
and the
documentation redistribution policy
.