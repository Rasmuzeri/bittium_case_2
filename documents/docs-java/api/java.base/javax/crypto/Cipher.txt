Cipher (Java SE 21 & JDK 21)
JavaScript is disabled on your browser.
Skip navigation links
Java SE 21 & JDK 21
Overview
Module
Package
Class
Use
Tree
Preview
New
Deprecated
Index
Help
Summary:
Nested
Field
Constr
Method
Detail:
Field
Constr
Method
Summary:
Nested |
Field
|
Constr
|
Method
Detail:
Field
|
Constr
|
Method
SEARCH
Module
java.base
Package
javax.crypto
Class Cipher
java.lang.Object
javax.crypto.Cipher
Direct Known Subclasses:
NullCipher
public class
Cipher
extends
Object
This class provides the functionality of a cryptographic cipher for
 encryption and decryption. It forms the core of the Java Cryptographic
 Extension (JCE) framework.
In order to create a
Cipher
object, the application calls the
 cipher's
getInstance
method, and passes the name of the
 requested
transformation
to it. Optionally, the name of a provider
 may be specified.
A
transformation
is a string that describes the operation (or
 set of operations) to be performed on the given input, to produce some
 output. A transformation always includes the name of a cryptographic
 algorithm (e.g.,
AES
), and may be followed by a feedback mode and
 padding scheme.
A transformation is of the form:
"
algorithm/mode/padding
" or
"
algorithm
"
(in the latter case,
 provider-specific default values for the mode and padding scheme are used).
 For example, the following is a valid transformation:
Cipher c = Cipher.getInstance("
AES/CBC/PKCS5Padding
");
Using modes such as
CFB
and
OFB
, block
 ciphers can encrypt data in units smaller than the cipher's actual
 block size.  When requesting such a mode, you may optionally specify
 the number of bits to be processed at a time by appending this number
 to the mode name as shown in the "
AES/CFB8/NoPadding
" and
 "
AES/OFB32/PKCS5Padding
" transformations. If no such
 number is specified, a provider-specific default is used.
 (See the
JDK Providers Documentation
for the JDK Providers default values.)
 Thus, block ciphers can be turned into byte-oriented stream ciphers by
 using an 8 bit mode such as CFB8 or OFB8.
Modes such as Authenticated Encryption with Associated Data (AEAD)
 provide authenticity assurances for both confidential data and
 Additional Associated Data (AAD) that is not encrypted.  (Please see
RFC 5116
for more
 information on AEAD and AAD algorithms such as GCM/CCM.) Both
 confidential and AAD data can be used when calculating the
 authentication tag (similar to a
Mac
).  This tag is appended
 to the ciphertext during encryption, and is verified on decryption.
AEAD modes such as GCM/CCM perform all AAD authenticity calculations
 before starting the ciphertext authenticity calculations.  To avoid
 implementations having to internally buffer ciphertext, all AAD data
 must be supplied to GCM/CCM implementations (via the
updateAAD
methods)
before
the ciphertext is processed (via
 the
update
and
doFinal
methods).
Note that GCM mode has a uniqueness requirement on IVs used in
 encryption with a given key. When IVs are repeated for GCM
 encryption, such usages are subject to forgery attacks. Thus, after
 each encryption operation using GCM mode, callers should re-initialize
 the
Cipher
objects with GCM parameters which have a different IV
 value.
GCMParameterSpec s = ...;
     cipher.init(..., s);

     // If the GCM parameters were generated by the provider, it can
     // be retrieved by:
     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);

     cipher.updateAAD(...);  // AAD
     cipher.update(...);     // Multi-part update
     cipher.doFinal(...);    // conclusion of operation

     // Use a different IV value for every encryption
     byte[] newIv = ...;
     s = new GCMParameterSpec(s.getTLen(), newIv);
     cipher.init(..., s);
     ...
The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement
 for unique nonces with a given key.  After each encryption or decryption
 operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305
 ciphers with parameters that specify a different nonce value.  Please
 see
RFC 7539
for more
 information on the ChaCha20 and ChaCha20-Poly1305 algorithms.
Every implementation of the Java platform is required to support
 the following standard
Cipher
object transformations with
 the keysizes in parentheses:
AES/CBC/NoPadding
(128)
AES/CBC/PKCS5Padding
(128)
AES/ECB/NoPadding
(128)
AES/ECB/PKCS5Padding
(128)
AES/GCM/NoPadding
(128)
DESede/CBC/NoPadding
(168)
DESede/CBC/PKCS5Padding
(168)
DESede/ECB/NoPadding
(168)
DESede/ECB/PKCS5Padding
(168)
RSA/ECB/PKCS1Padding
(1024, 2048)
RSA/ECB/OAEPWithSHA-1AndMGF1Padding
(1024, 2048)
RSA/ECB/OAEPWithSHA-256AndMGF1Padding
(1024, 2048)
These transformations are described in the
Cipher section
of the
 Java Security Standard Algorithm Names Specification.
 Consult the release documentation for your implementation to see if any
 other transformations are supported.
Since:
1.4
See Also:
KeyGenerator
SecretKey
Field Summary
Fields
Modifier and Type
Field
Description
static final int
DECRYPT_MODE
Constant used to initialize cipher to decryption mode.
static final int
ENCRYPT_MODE
Constant used to initialize cipher to encryption mode.
static final int
PRIVATE_KEY
Constant used to indicate the to-be-unwrapped key is a "private key".
static final int
PUBLIC_KEY
Constant used to indicate the to-be-unwrapped key is a "public key".
static final int
SECRET_KEY
Constant used to indicate the to-be-unwrapped key is a "secret key".
static final int
UNWRAP_MODE
Constant used to initialize cipher to key-unwrapping mode.
static final int
WRAP_MODE
Constant used to initialize cipher to key-wrapping mode.
Constructor Summary
Constructors
Modifier
Constructor
Description
protected
Cipher
(
CipherSpi
cipherSpi,
Provider
provider,
String
transformation)
Creates a
Cipher
object.
Method Summary
All Methods
Static Methods
Instance Methods
Concrete Methods
Modifier and Type
Method
Description
final byte[]
doFinal
()
Finishes a multiple-part encryption or decryption operation, depending
 on how this
Cipher
object was initialized.
final byte[]
doFinal
(byte[] input)
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.
final int
doFinal
(byte[] output,
 int outputOffset)
Finishes a multiple-part encryption or decryption operation, depending
 on how this
Cipher
object was initialized.
final byte[]
doFinal
(byte[] input,
 int inputOffset,
 int inputLen)
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.
final int
doFinal
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output)
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.
final int
doFinal
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output,
 int outputOffset)
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.
final int
doFinal
(
ByteBuffer
input,
ByteBuffer
output)
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.
final
String
getAlgorithm
()
Returns the algorithm name of this
Cipher
object.
final int
getBlockSize
()
Returns the block size (in bytes).
final
ExemptionMechanism
getExemptionMechanism
()
Returns the exemption mechanism object used with this
Cipher
object.
static final
Cipher
getInstance
(
String
transformation)
Returns a
Cipher
object that implements the specified
 transformation.
static final
Cipher
getInstance
(
String
transformation,
String
provider)
Returns a
Cipher
object that implements the specified
 transformation.
static final
Cipher
getInstance
(
String
transformation,
Provider
provider)
Returns a
Cipher
object that implements the specified
 transformation.
final byte[]
getIV
()
Returns the initialization vector (IV) in a new buffer.
static final int
getMaxAllowedKeyLength
(
String
transformation)
Returns the maximum key length for the specified transformation
 according to the installed JCE jurisdiction policy files.
static final
AlgorithmParameterSpec
getMaxAllowedParameterSpec
(
String
transformation)
Returns an {code AlgorithmParameterSpec} object which contains
 the maximum
Cipher
parameter value according to the
 jurisdiction policy file.
final int
getOutputSize
(int inputLen)
Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next
update
or
doFinal
operation, given the input length
inputLen
(in bytes).
final
AlgorithmParameters
getParameters
()
Returns the parameters used with this
Cipher
object.
final
Provider
getProvider
()
Returns the provider of this
Cipher
object.
final void
init
(int opmode,
Certificate
certificate)
Initializes this
Cipher
object with the public key from the given
 certificate.
final void
init
(int opmode,
Certificate
certificate,
SecureRandom
random)
Initializes this
Cipher
object with the public key from the given
 certificate and a source of randomness.
final void
init
(int opmode,
Key
key)
Initializes this
Cipher
object with a key.
final void
init
(int opmode,
Key
key,
AlgorithmParameters
params)
Initializes this
Cipher
object with a key and a set of algorithm
 parameters.
final void
init
(int opmode,
Key
key,
AlgorithmParameters
params,
SecureRandom
random)
Initializes this
Cipher
object with a key, a set of algorithm
 parameters, and a source of randomness.
final void
init
(int opmode,
Key
key,
SecureRandom
random)
Initializes this
Cipher
object with a key and a
 source of randomness.
final void
init
(int opmode,
Key
key,
AlgorithmParameterSpec
params)
Initializes this
Cipher
object with a key and a set of algorithm
 parameters.
final void
init
(int opmode,
Key
key,
AlgorithmParameterSpec
params,
SecureRandom
random)
Initializes this
Cipher
object with a key, a set of algorithm
 parameters, and a source of randomness.
String
toString
()
Returns a
String
representation of this
Cipher
object.
final
Key
unwrap
(byte[] wrappedKey,
String
wrappedKeyAlgorithm,
 int wrappedKeyType)
Unwrap a previously wrapped key.
final byte[]
update
(byte[] input)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
final byte[]
update
(byte[] input,
 int inputOffset,
 int inputLen)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
final int
update
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
final int
update
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output,
 int outputOffset)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
final int
update
(
ByteBuffer
input,
ByteBuffer
output)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
final void
updateAAD
(byte[] src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
final void
updateAAD
(byte[] src,
 int offset,
 int len)
Continues a multi-part update of the Additional Authentication
 Data (AAD), using a subset of the provided buffer.
final void
updateAAD
(
ByteBuffer
src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
final byte[]
wrap
(
Key
key)
Wrap a key.
Methods declared in class java.lang.
Object
clone
,
equals
,
finalize
,
getClass
,
hashCode
,
notify
,
notifyAll
,
wait
,
wait
,
wait
Field Details
ENCRYPT_MODE
public static final
int
ENCRYPT_MODE
Constant used to initialize cipher to encryption mode.
See Also:
Constant Field Values
DECRYPT_MODE
public static final
int
DECRYPT_MODE
Constant used to initialize cipher to decryption mode.
See Also:
Constant Field Values
WRAP_MODE
public static final
int
WRAP_MODE
Constant used to initialize cipher to key-wrapping mode.
See Also:
Constant Field Values
UNWRAP_MODE
public static final
int
UNWRAP_MODE
Constant used to initialize cipher to key-unwrapping mode.
See Also:
Constant Field Values
PUBLIC_KEY
public static final
int
PUBLIC_KEY
Constant used to indicate the to-be-unwrapped key is a "public key".
See Also:
Constant Field Values
PRIVATE_KEY
public static final
int
PRIVATE_KEY
Constant used to indicate the to-be-unwrapped key is a "private key".
See Also:
Constant Field Values
SECRET_KEY
public static final
int
SECRET_KEY
Constant used to indicate the to-be-unwrapped key is a "secret key".
See Also:
Constant Field Values
Constructor Details
Cipher
protected
Cipher
(
CipherSpi
cipherSpi,
Provider
provider,
String
transformation)
Creates a
Cipher
object.
Parameters:
cipherSpi
- the delegate
provider
- the provider
transformation
- the transformation
Throws:
NullPointerException
- if
provider
is
null
IllegalArgumentException
- if the supplied arguments
         are deemed invalid for constructing the
Cipher
object
Method Details
getInstance
public static final
Cipher
getInstance
(
String
transformation)
throws
NoSuchAlgorithmException
,
NoSuchPaddingException
Returns a
Cipher
object that implements the specified
 transformation.
This method traverses the list of registered security providers,
 starting with the most preferred provider.
 A new
Cipher
object encapsulating the
CipherSpi
implementation from the first
 provider that supports the specified algorithm is returned.
Note that the list of registered providers may be retrieved via
 the
Security.getProviders()
method.
API Note:
It is recommended to use a transformation that fully specifies the
 algorithm, mode, and padding. By not doing so, the provider will
 use a default for the mode and padding which may not meet the security
 requirements of your application.
Implementation Note:
The JDK Reference Implementation additionally uses the
jdk.security.provider.preferred
Security
property to determine
 the preferred provider order for the specified algorithm. This
 may be different than the order of providers returned by
Security.getProviders()
.
 See also the Cipher Transformations section of the
JDK Providers
document for information
 on the transformation defaults used by JDK providers.
Parameters:
transformation
- the name of the transformation, e.g.,
AES/CBC/PKCS5Padding
.
 See the Cipher section in the
Java Security Standard Algorithm Names Specification
for information about standard transformation names.
Returns:
a
Cipher
object that implements the requested
 transformation
Throws:
NoSuchAlgorithmException
- if
transformation
is
null
, empty, in an invalid format,
         or if no provider supports a
CipherSpi
implementation for the specified algorithm
NoSuchPaddingException
- if
transformation
contains a padding scheme that is not available
See Also:
Provider
getInstance
public static final
Cipher
getInstance
(
String
transformation,
String
provider)
throws
NoSuchAlgorithmException
,
NoSuchProviderException
,
NoSuchPaddingException
Returns a
Cipher
object that implements the specified
 transformation.
A new
Cipher
object encapsulating the
CipherSpi
implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.
Note that the list of registered providers may be retrieved via
 the
Security.getProviders()
method.
API Note:
It is recommended to use a transformation that fully specifies the
 algorithm, mode, and padding. By not doing so, the provider will
 use a default for the mode and padding which may not meet the security
 requirements of your application.
Implementation Note:
See the Cipher Transformations section of the
JDK Providers
document for information
 on the transformation defaults used by JDK providers.
Parameters:
transformation
- the name of the transformation,
 e.g.,
AES/CBC/PKCS5Padding
.
 See the Cipher section in the
Java Security Standard Algorithm Names Specification
for information about standard transformation names.
provider
- the name of the provider
Returns:
a
Cipher
object that implements the requested
 transformation
Throws:
IllegalArgumentException
- if the
provider
is
null
or empty
NoSuchAlgorithmException
- if
transformation
is
null
, empty, in an invalid format,
         or if a
CipherSpi
implementation for the
         specified algorithm is not available from the specified
         provider
NoSuchPaddingException
- if
transformation
contains a padding scheme that is not available
NoSuchProviderException
- if the specified provider is not
         registered in the security provider list
See Also:
Provider
getInstance
public static final
Cipher
getInstance
(
String
transformation,
Provider
provider)
throws
NoSuchAlgorithmException
,
NoSuchPaddingException
Returns a
Cipher
object that implements the specified
 transformation.
A new
Cipher
object encapsulating the
CipherSpi
implementation from the specified
provider
object is returned.  Note that the specified
provider
object
 does not have to be registered in the provider list.
API Note:
It is recommended to use a transformation that fully specifies the
 algorithm, mode, and padding. By not doing so, the provider will
 use a default for the mode and padding which may not meet the security
 requirements of your application.
Implementation Note:
See the Cipher Transformations section of the
JDK Providers
document for information
 on the transformation defaults used by JDK providers.
Parameters:
transformation
- the name of the transformation,
 e.g.,
AES/CBC/PKCS5Padding
.
 See the Cipher section in the
Java Security Standard Algorithm Names Specification
for information about standard transformation names.
provider
- the provider
Returns:
a
Cipher
object that implements the requested
 transformation
Throws:
IllegalArgumentException
- if the
provider
is
null
NoSuchAlgorithmException
- if
transformation
is
null
, empty, in an invalid format,
         or if a
CipherSpi
implementation for the
         specified algorithm is not available from the specified
provider
object
NoSuchPaddingException
- if
transformation
contains a padding scheme that is not available
See Also:
Provider
getProvider
public final
Provider
getProvider
()
Returns the provider of this
Cipher
object.
Returns:
the provider of this
Cipher
object
getAlgorithm
public final
String
getAlgorithm
()
Returns the algorithm name of this
Cipher
object.
This is the same name that was specified in one of the
getInstance
calls that created this
Cipher
object.
Returns:
the algorithm name of this
Cipher
object
getBlockSize
public final
int
getBlockSize
()
Returns the block size (in bytes).
Returns:
the block size (in bytes), or 0 if this cipher is
 not a block cipher
getOutputSize
public final
int
getOutputSize
(int inputLen)
Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next
update
or
doFinal
operation, given the input length
inputLen
(in bytes).
This call takes into account any unprocessed (buffered) data from a
 previous
update
call, padding, and AEAD tagging.
The actual output length of the next
update
or
doFinal
call may be smaller than the length returned by
 this method.
Parameters:
inputLen
- the input length (in bytes)
Returns:
the required output buffer size (in bytes)
Throws:
IllegalStateException
- if this
Cipher
object is in a
 wrong state (e.g., has not yet been initialized)
getIV
public final
byte[]
getIV
()
Returns the initialization vector (IV) in a new buffer.
This is useful in the case where a random IV was created,
 or in the context of password-based encryption or
 decryption, where the IV is derived from a user-supplied password.
Returns:
the initialization vector in a new buffer, or
null
if
 this cipher does not use an IV, or if the IV has not yet
 been set.
getParameters
public final
AlgorithmParameters
getParameters
()
Returns the parameters used with this
Cipher
object.
The returned parameters may be the same that were used to initialize
 this cipher, or may contain additional default or random parameter
 values used by the underlying cipher implementation. If the required
 parameters were not supplied and can be generated by the cipher, the
 generated parameters are returned. Otherwise,
null
is returned.
Returns:
the parameters used with this cipher, or
null
getExemptionMechanism
public final
ExemptionMechanism
getExemptionMechanism
()
Returns the exemption mechanism object used with this
Cipher
object.
Returns:
the exemption mechanism object used with this
Cipher
object, or
null
if this
Cipher
object does not use any
 exemption mechanism.
init
public final
void
init
(int opmode,
Key
key)
throws
InvalidKeyException
Initializes this
Cipher
object with a key.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters that cannot be
 derived from the given
key
, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidKeyException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
SecureRandom
implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the key
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or requires
 algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Key
key,
SecureRandom
random)
throws
InvalidKeyException
Initializes this
Cipher
object with a key and a
 source of randomness.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters that cannot be
 derived from the given
key
, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidKeyException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from
random
.
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the encryption key
random
- the source of randomness
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or requires
 algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Key
key,
AlgorithmParameterSpec
params)
throws
InvalidKeyException
,
InvalidAlgorithmParameterException
Initializes this
Cipher
object with a key and a set of algorithm
 parameters.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters and
params
is
null
, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidAlgorithmParameterException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
SecureRandom
implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the encryption key
params
- the algorithm parameters
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files)
InvalidAlgorithmParameterException
- if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and
params
is
null
, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Key
key,
AlgorithmParameterSpec
params,
SecureRandom
random)
throws
InvalidKeyException
,
InvalidAlgorithmParameterException
Initializes this
Cipher
object with a key, a set of algorithm
 parameters, and a source of randomness.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters and
params
is
null
, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidAlgorithmParameterException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from
random
.
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the encryption key
params
- the algorithm parameters
random
- the source of randomness
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files)
InvalidAlgorithmParameterException
- if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and
params
is
null
, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Key
key,
AlgorithmParameters
params)
throws
InvalidKeyException
,
InvalidAlgorithmParameterException
Initializes this
Cipher
object with a key and a set of algorithm
 parameters.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters and
params
is
null
, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidAlgorithmParameterException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
SecureRandom
implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the encryption key
params
- the algorithm parameters
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
InvalidAlgorithmParameterException
- if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and
params
is
null
, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Key
key,
AlgorithmParameters
params,
SecureRandom
random)
throws
InvalidKeyException
,
InvalidAlgorithmParameterException
Initializes this
Cipher
object with a key, a set of algorithm
 parameters, and a source of randomness.
The
Cipher
object is initialized for one of the following four
 operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If this cipher requires any algorithm parameters and
params
is
null
, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidAlgorithmParameterException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from
random
.
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
key
- the encryption key
params
- the algorithm parameters
random
- the source of randomness
Throws:
InvalidKeyException
- if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files)
InvalidAlgorithmParameterException
- if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and
params
is
null
, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Certificate
certificate)
throws
InvalidKeyException
Initializes this
Cipher
object with the public key from the given
 certificate.
The
Cipher
object is initialized for one of the following
 four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of
opmode
.
If the certificate is of type X.509 and has a
key usage
extension field marked as critical, and the value of the
key usage
extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value
 of
opmode
,
 an
InvalidKeyException
is thrown.
If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given certificate, the underlying
 cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidKeyException
if it is being initialized for decryption or
 key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
SecureRandom
implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
certificate
- the certificate
Throws:
InvalidKeyException
- if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
init
public final
void
init
(int opmode,
Certificate
certificate,
SecureRandom
random)
throws
InvalidKeyException
Initializes this
Cipher
object with the public key from the given
 certificate and a source of randomness.
The
Cipher
object is initialized for one of the following four
 operations: encryption, decryption, key wrapping
 or key unwrapping, depending on
 the value of
opmode
.
If the certificate is of type X.509 and has a
key usage
extension field marked as critical, and the value of the
key usage
extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value of
opmode
,
 an
InvalidKeyException
is thrown.
If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given
certificate
,
 the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
InvalidKeyException
if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
getParameters
or
getIV
(if the parameter is an IV).
If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.
If this cipher (including its feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from
random
.
Note that when a
Cipher
object is initialized, it loses all
 previously-acquired state. In other words, initializing a
Cipher
object is equivalent to creating a new instance of that
Cipher
object and initializing it.
Parameters:
opmode
- the operation mode of this
Cipher
object
 (this is one of the following:
ENCRYPT_MODE
,
DECRYPT_MODE
,
WRAP_MODE
or
UNWRAP_MODE
)
certificate
- the certificate
random
- the source of randomness
Throws:
InvalidKeyException
- if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher
 requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files)
UnsupportedOperationException
- if
opmode
is
WRAP_MODE
or
UNWRAP_MODE
but the mode is not implemented
 by the underlying
CipherSpi
InvalidParameterException
- if
opmode
is not one of the
 recognized values
update
public final
byte[]
update
(byte[] input)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
The bytes in the
input
buffer are processed, and the
 result is stored in a new buffer.
If
input
has a length of zero, this method returns
null
.
Parameters:
input
- the input buffer
Returns:
the new buffer with the result, or
null
if this
 cipher is a block cipher and the input data is too short to result in a
 new block
Throws:
IllegalStateException
- if this
Cipher
object is in a
 wrong state (e.g., has not been initialized)
update
public final
byte[]
update
(byte[] input,
 int inputOffset,
 int inputLen)
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, are processed,
 and the result is stored in a new buffer.
If
inputLen
is zero, this method returns
null
.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
Returns:
the new buffer with the result, or
null
if this
 cipher is a block cipher and the input data is too short to result in a
 new block.
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
update
public final
int
update
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output)
throws
ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, are processed,
 and the result is stored in the
output
buffer.
If the
output
buffer is too small to hold the result,
 a
ShortBufferException
is thrown. In this case, repeat this
 call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
If
inputLen
is zero, this method returns
 a length of zero.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
output
- the buffer for the result
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
ShortBufferException
- if the given output buffer is too small
 to hold the result
update
public final
int
update
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output,
 int outputOffset)
throws
ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, are processed,
 and the result is stored in the
output
buffer, starting at
outputOffset
inclusive.
If the
output
buffer is too small to hold the result,
 a
ShortBufferException
is thrown. In this case, repeat this
 call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
If
inputLen
is zero, this method returns
 a length of zero.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
output
- the buffer for the result
outputOffset
- the offset in
output
where the result
 is stored
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
ShortBufferException
- if the given output buffer is too small
 to hold the result
update
public final
int
update
(
ByteBuffer
input,
ByteBuffer
output)
throws
ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this
Cipher
object was initialized),
 processing another data part.
All
input.remaining()
bytes starting at
input.position()
are processed. The result is stored
 in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.
If
output.remaining()
bytes are insufficient to
 hold the result, a
ShortBufferException
is thrown.
 In this case, repeat this call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same block of memory and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input ByteBuffer
output
- the output ByteByffer
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalArgumentException
- if input and output are the
   same object
ReadOnlyBufferException
- if the output buffer is read-only
ShortBufferException
- if there is insufficient space in the
 output buffer
Since:
1.5
doFinal
public final
byte[]
doFinal
()
                     throws
IllegalBlockSizeException
,
BadPaddingException
Finishes a multiple-part encryption or decryption operation, depending
 on how this
Cipher
object was initialized.
Input data that may have been buffered during a previous
update
operation is processed, with padding (if requested)
 being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Returns:
the new buffer with the result
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the decrypted
 data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
int
doFinal
(byte[] output,
 int outputOffset)
throws
IllegalBlockSizeException
,
ShortBufferException
,
BadPaddingException
Finishes a multiple-part encryption or decryption operation, depending
 on how this
Cipher
object was initialized.
Input data that may have been buffered during a previous
update
operation is processed, with padding (if requested)
 being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the
output
buffer, starting at
outputOffset
inclusive.
If the
output
buffer is too small to hold the result,
 a
ShortBufferException
is thrown. In this case, repeat this
 call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
Upon finishing, this method resets this
Cipher
object
  to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Parameters:
output
- the buffer for the result
outputOffset
- the offset in
output
where the result
 is stored
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
  is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException
- if the given output buffer is too small
 to hold the result
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the
 decrypted data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
byte[]
doFinal
(byte[] input)
throws
IllegalBlockSizeException
,
BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this
Cipher
object was initialized.
The bytes in the
input
buffer, and any input bytes that
 may have been buffered during a previous
update
operation,
 are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Parameters:
input
- the input buffer
Returns:
the new buffer with the result
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the
 decrypted data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
byte[]
doFinal
(byte[] input,
 int inputOffset,
 int inputLen)
throws
IllegalBlockSizeException
,
BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this
Cipher
object was initialized.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, and any input
 bytes that may have been buffered during a previous
update
operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
Returns:
the new buffer with the result
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the decrypted
 data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
int
doFinal
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output)
throws
ShortBufferException
,
IllegalBlockSizeException
,
BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this
Cipher
object was initialized.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, and any input
 bytes that may have been buffered during a previous
update
operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the
output
buffer.
If the
output
buffer is too small to hold the result,
 a
ShortBufferException
is thrown. In this case, repeat this
 call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
output
- the buffer for the result
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException
- if the given output buffer is too small
 to hold the result
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the decrypted
 data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
int
doFinal
(byte[] input,
 int inputOffset,
 int inputLen,
 byte[] output,
 int outputOffset)
throws
ShortBufferException
,
IllegalBlockSizeException
,
BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this
Cipher
object was initialized.
The first
inputLen
bytes in the
input
buffer, starting at
inputOffset
inclusive, and any input
 bytes that may have been buffered during a previous
update
operation, are processed, with padding
 (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the
output
buffer, starting at
outputOffset
inclusive.
If the
output
buffer is too small to hold the result,
 a
ShortBufferException
is thrown. In this case, repeat this
 call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input buffer
inputOffset
- the offset in
input
where the input
 starts
inputLen
- the input length
output
- the buffer for the result
outputOffset
- the offset in
output
where the result
 is stored
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException
- if the given output buffer is too small
 to hold the result
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the decrypted
 data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
doFinal
public final
int
doFinal
(
ByteBuffer
input,
ByteBuffer
output)
throws
ShortBufferException
,
IllegalBlockSizeException
,
BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this
Cipher
object was initialized.
All
input.remaining()
bytes starting at
input.position()
are processed.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.
If
output.remaining()
bytes are insufficient to
 hold the result, a
ShortBufferException
is thrown.
 In this case, repeat this call with a larger output buffer. Use
getOutputSize
to determine how big
 the output buffer should be.
Upon finishing, this method resets this
Cipher
object
 to the state it was in when previously initialized via a call to
init
.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
init
) more data.
Note: if any exception is thrown, this
Cipher
object
 may need to be reset before it can be used again.
Note: this method should be copy-safe, which means the
input
and
output
buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.
Parameters:
input
- the input ByteBuffer
output
- the output ByteBuffer
Returns:
the number of bytes stored in
output
Throws:
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized)
IllegalArgumentException
- if input and output are the
   same object
ReadOnlyBufferException
- if the output buffer is read-only
IllegalBlockSizeException
- if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException
- if there is insufficient space in the
 output buffer
BadPaddingException
- if this
Cipher
object is in
 decryption mode, and (un)padding has been requested, but the
 decrypted data is not bounded by the appropriate padding bytes
AEADBadTagException
- if this
Cipher
object is decrypting
 in an AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
Since:
1.5
wrap
public final
byte[]
wrap
(
Key
key)
throws
IllegalBlockSizeException
,
InvalidKeyException
Wrap a key.
Parameters:
key
- the key to be wrapped
Returns:
the wrapped key
Throws:
IllegalStateException
- if this
Cipher
object is in a wrong
 state (e.g., has not been initialized)
IllegalBlockSizeException
- if this cipher is a block
 cipher, no padding has been requested, and the length of the
 encoding of the key to be wrapped is not a
 multiple of the block size
InvalidKeyException
- if it is impossible or unsafe to
 wrap the key with this cipher (e.g., a hardware protected key is
 being passed to a software-only cipher)
UnsupportedOperationException
- if the corresponding method in the
CipherSpi
is not supported
unwrap
public final
Key
unwrap
(byte[] wrappedKey,
String
wrappedKeyAlgorithm,
 int wrappedKeyType)
throws
InvalidKeyException
,
NoSuchAlgorithmException
Unwrap a previously wrapped key.
Parameters:
wrappedKey
- the key to be unwrapped
wrappedKeyAlgorithm
- the algorithm associated with the wrapped
 key
wrappedKeyType
- the type of the wrapped key. This must be one of
SECRET_KEY
,
PRIVATE_KEY
, or
PUBLIC_KEY
Returns:
the unwrapped key
Throws:
IllegalStateException
- if this
Cipher
object
  is in a wrong state (e.g., has not been initialized)
NoSuchAlgorithmException
- if no installed providers
 can create keys of type
wrappedKeyType
for the
wrappedKeyAlgorithm
InvalidKeyException
- if
wrappedKey
does not
 represent a wrapped key of type
wrappedKeyType
for
 the
wrappedKeyAlgorithm
UnsupportedOperationException
- if the corresponding method in the
CipherSpi
is not supported
getMaxAllowedKeyLength
public static final
int
getMaxAllowedKeyLength
(
String
transformation)
throws
NoSuchAlgorithmException
Returns the maximum key length for the specified transformation
 according to the installed JCE jurisdiction policy files. If
 JCE unlimited strength jurisdiction policy files are installed,
Integer.MAX_VALUE
will be returned.
 For more information on the default key sizes and the JCE jurisdiction
 policy files, please see the Cryptographic defaults and limitations in
 the
JDK Providers Documentation
.
Parameters:
transformation
- the cipher transformation
Returns:
the maximum key length in bits or
Integer.MAX_VALUE
Throws:
NullPointerException
- if
transformation
is
null
NoSuchAlgorithmException
- if
transformation
is not a valid transformation, i.e. in the form of "algorithm" or
 "algorithm/mode/padding"
Since:
1.5
getMaxAllowedParameterSpec
public static final
AlgorithmParameterSpec
getMaxAllowedParameterSpec
(
String
transformation)
throws
NoSuchAlgorithmException
Returns an {code AlgorithmParameterSpec} object which contains
 the maximum
Cipher
parameter value according to the
 jurisdiction policy file. If JCE unlimited strength jurisdiction
 policy files are installed or there is no maximum limit on the
 parameters for the specified transformation in the policy file,
null
will be returned.
Parameters:
transformation
- the cipher transformation
Returns:
an {code AlgorithmParameterSpec} object which holds the maximum
 value or
null
Throws:
NullPointerException
- if
transformation
is
null
NoSuchAlgorithmException
- if
transformation
is not a valid transformation, i.e. in the form of "algorithm" or
 "algorithm/mode/padding"
Since:
1.5
updateAAD
public final
void
updateAAD
(byte[] src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
Calls to this method provide AAD to the
Cipher
object
 when operating in modes such as AEAD (GCM/CCM).  If this
Cipher
object is operating in either GCM or CCM mode, all AAD
 must be supplied before beginning operations on the ciphertext
 (via the
update
and
doFinal
methods).
Parameters:
src
- the buffer containing the Additional Authentication Data
Throws:
IllegalArgumentException
- if the
src
byte array is
null
IllegalStateException
- if this
Cipher
object
  is in a wrong state (e.g., has not been initialized),
 does not accept AAD, or if operating in either GCM or CCM mode and
 one of the
update
methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException
- if the corresponding method
 in the
CipherSpi
has not been overridden by an
 implementation
Since:
1.7
updateAAD
public final
void
updateAAD
(byte[] src,
 int offset,
 int len)
Continues a multi-part update of the Additional Authentication
 Data (AAD), using a subset of the provided buffer.
Calls to this method provide AAD to the
Cipher
object
 when operating in modes such as AEAD (GCM/CCM).  If this
Cipher
object is operating in either GCM or CCM mode,
 all AAD must be supplied before beginning operations on the
 ciphertext (via the
update
and
doFinal
methods).
Parameters:
src
- the buffer containing the AAD
offset
- the offset in
src
where the AAD input starts
len
- the number of AAD bytes
Throws:
IllegalArgumentException
- if the
src
byte array is
null
, or the
offset
or
length
is less than 0, or the sum of the
offset
and
len
is greater than the length of the
src
byte array
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized),
 does not accept AAD, or if operating in either GCM or CCM mode and
 one of the
update
methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException
- if the corresponding method
 in the
CipherSpi
has not been overridden by an
 implementation
Since:
1.7
updateAAD
public final
void
updateAAD
(
ByteBuffer
src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
Calls to this method provide AAD to the
Cipher
object
 when operating in modes such as AEAD (GCM/CCM).  If this
Cipher
object is operating in either GCM or CCM mode, all AAD
 must be supplied before beginning operations on the ciphertext
 (via the
update
and
doFinal
methods).
All
src.remaining()
bytes starting at
src.position()
are processed.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed.
Parameters:
src
- the buffer containing the AAD
Throws:
IllegalArgumentException
- if the
src ByteBuffer
is
null
IllegalStateException
- if this
Cipher
object
 is in a wrong state (e.g., has not been initialized),
 does not accept AAD, or if operating in either GCM or CCM mode and
 one of the
update
methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException
- if the corresponding method
 in the
CipherSpi
has not been overridden by an
 implementation
Since:
1.7
toString
public
String
toString
()
Returns a
String
representation of this
Cipher
object.
Overrides:
toString
in class
Object
Implementation Note:
This implementation returns a
String
containing the
 transformation, mode, and provider of this
Cipher
object.
 The exact format of the
String
is unspecified and is subject
 to change.
Returns:
a String describing this
Cipher
object
Report a bug or suggest an enhancement
For further API reference and developer documentation see the
Java SE Documentation
, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.
Other versions.
Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.
Copyright
© 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.
All rights reserved. Use is subject to
license terms
and the
documentation redistribution policy
.